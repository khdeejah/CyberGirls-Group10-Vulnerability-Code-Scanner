#!/bin/bash

# Function to check if a command exists
check_command() {
  command -v "$1" >/dev/null 2>&1
}

# Prompt the user to confirm if they have 'ag' installed
echo "This script uses 'ag' (The Silver Searcher) to scan for security patterns in your code."
read -p "Do you already have 'ag' installed on your system? (y/n): " ag_installed

# If the user does not have 'ag' installed, offer to install it
if [[ "$ag_installed" =~ ^[Nn]$ ]]; then
  echo "'ag' is not installed on your system."
  read -p "Would you like to install it now? (y/n): " install_choice
  if [[ "$install_choice" =~ ^[Yy]$ ]]; then
    echo "Installing 'ag'..."
    sudo apt update
    sudo apt install silversearcher-ag -y
    if [ $? -ne 0 ]; then
      echo "Failed to install 'ag'. Please install it manually and re-run the script."
      exit 1
    else
      echo "'ag' has been installed successfully."
    fi
  else
    echo "'ag' is required to run this script. Exiting."
    exit 1
  fi
elif [[ "$ag_installed" =~ ^[Yy]$ ]]; then
  if check_command ag; then
    echo "'ag' is already installed on your system."
  else
    echo "You indicated that 'ag' is installed, but it was not found on your system. Please install it and re-run the script."
    exit 1
  fi
else
  echo "Invalid input. Please run the script again and respond with 'y' or 'n'."
  exit 1
fi


# Prompt user for the path to the source code file or directory
read -p "Enter the path to the source code file or directory to scan: " path

# Check if the provided path is valid
if [ ! -e "$path" ]; then
  echo "The provided path does not exist."
  exit 1
fi

# Define output files
temp_output_file="scan_results_temp.txt"
log_file="scan_results_log_.txt"

# Clear or create the temporary output file
> "$temp_output_file"

# Initialize a flag to track if any patterns were found
patterns_found="false"

# Define patterns and their associated metadata
declare -A patterns

# Metadata structure: "Issue|Severity|OWASP Category|CVE ID|Remediation"
patterns=(
  ["SELECT .* FROM .* WHERE .*="]="SQL Injection|High|A1: Injection|CVE-2019-12086|Use prepared statements and parameterized queries."
  ["os.system"]="Command Injection|High|A1: Injection|CVE-2018-1000098|Use subprocess.run() with a list of arguments instead of os.system()."
  ["subprocess.Popen"]="Command Injection|High|A1: Injection|CVE-2018-1000098|Use subprocess.run() with a list of arguments instead of subprocess.Popen()."
  ["exec"]="Command Injection|High|A1: Injection|CVE-2018-1000098|Avoid using exec(). Use safer alternatives."
  ["eval"]="Command Injection|High|A1: Injection|CVE-2018-1000098|Avoid using eval(). Use safer alternatives."
  ["system"]="Command Injection|High|A1: Injection|CVE-2018-1000098|Avoid using system(). Use safer alternatives."
  ["document.write"]="Cross-Site Scripting (XSS)|High|A7: Cross-Site Scripting (XSS)|CVE-2019-11358|Avoid using document.write(). Use safer alternatives."
  ["innerHTML"]="Cross-Site Scripting (XSS)|High|A7: Cross-Site Scripting (XSS)|CVE-2019-11358|Avoid using innerHTML. Use safer alternatives."
  ["outerHTML"]="Cross-Site Scripting (XSS)|High|A7: Cross-Site Scripting (XSS)|CVE-2019-11358|Avoid using outerHTML. Use safer alternatives."
  ["html()"]="Cross-Site Scripting (XSS)|High|A7: Cross-Site Scripting (XSS)|CVE-2019-11358|Avoid using html(). Use safer alternatives."
  ["DEBUG = True"]="Debug Mode Enabled|Medium|A5: Security Misconfiguration|N/A|Disable debug mode in production."
  ["ALLOWED_HOSTS = \[\]"]="Improper Host Configuration|Medium|A5: Security Misconfiguration|N/A|Specify allowed hosts in production."
  ["SECRET_KEY = ''"]="Hardcoded Secret Key|Medium|A5: Security Misconfiguration|N/A|Use a strong, unique secret key."
  ["ENV = 'development'"]="Development Environment|Medium|A5: Security Misconfiguration|N/A|Set the environment to production in production settings."
  ["private static final String"]="Hardcoded Sensitive Information|Medium|A5: Security Misconfiguration|N/A|Avoid hardcoding sensitive information. Use environment variables or configuration files."
  ["pbkdf2_sha256.encrypt"]="Weak Password Hashing|High|A3: Sensitive Data Exposure|CVE-2016-5080|Use pbkdf2_sha256.hash instead of encrypt for password hashing."
  ["INSERT INTO .* VALUES (.*%s.*)"]="SQL Injection|High|A1: Injection|CVE-2019-12086|Use parameterized queries to prevent SQL injection."
  ["for \(.*;.*<.*;.*\)"]="Potential DoS|Medium|A6: Security Misconfiguration|N/A|Avoid looping through user input directly. Validate and limit input size."
  ["\$_GET\[.*\]"]="Unsanitized GET Parameter|High|A1: Injection|CVE-2020-7071|Validate and sanitize all GET parameters."
  ["mysqli_query"]="SQL Injection|High|A1: Injection|CVE-2019-12086|Use prepared statements and parameterized queries with MySQLi."
  ["console.log"]="Debugging Code|Low|A5: Security Misconfiguration|N/A|Remove debugging code before production."
  ["print("]="Debugging Code|Low|A5: Security Misconfiguration|N/A|Remove debugging code before production."
  ["TODO:"]="Code TODO|Low|A5: Security Misconfiguration|N/A|Address TODO comments before production release."
  ["FIXME:"]="Code FIXME|Low|A5: Security Misconfiguration|N/A|Fix FIXME comments before production release."
)

# Function to log findings to the temporary file
log_findings() {
  local file="$1"
  local line="$2"
  local code="$3"
  local issue="$4"
  local severity="$5"
  local owasp="$6"
  local cve="$7"
  local remediation="$8"

  echo "File: $file" >> "$temp_output_file"
  echo "Line: $line" >> "$temp_output_file"
  echo "Code: $code" >> "$temp_output_file"
  echo "Issue: $issue" >> "$temp_output_file"
  echo "Severity: $severity" >> "$temp_output_file"
  echo "OWASP: $owasp" >> "$temp_output_file"
  echo "CVE: $cve" >> "$temp_output_file"
  echo "Remediation: $remediation" >> "$temp_output_file"
  echo "----------------------------------" >> "$temp_output_file"
  echo " " >> "$temp_output_file"
}

# Runs ag and log findings
run_ag() {
  local pattern="$1"

  # Extracts metadata from the patterns array
  local metadata="${patterns[$pattern]}"

  # Split metadata into components
  IFS='|' read -r -a meta <<< "$metadata"
  local issue="${meta[0]}"
  local severity="${meta[1]}"
  local owasp="${meta[2]}"
  local cve="${meta[3]}"
  local remediation="${meta[4]}"

  # Display date, time, and scanning issue
  echo "$(date '+%Y-%m-%d %H:%M:%S') - Scanning code for vulnerability: $issue"

  # Record start time
  local start_time=$(date +%s)

  # Search for the pattern in the specified path and log findings
  if ag -rn "$pattern" "$path" &> /dev/null; then
    ag -rn "$pattern" "$path" | while read -r result; do
      file=$(echo "$result" | cut -d: -f1)
      line=$(echo "$result" | cut -d: -f2)
      code=$(echo "$result" | cut -d: -f3-)
      log_findings "$file" "$line" "$code" "$issue" "$severity" "$owasp" "$cve" "$remediation"
    done
    patterns_found="true"
  fi

  # Record end time and calculate elapsed time
  local end_time=$(date +%s)
  local elapsed_time=$((end_time - start_time))

  echo "$(date '+%Y-%m-%d %H:%M:%S') - Finished scanning for $issue in ${elapsed_time}s"
}

# Start the scan
echo "Scan has started..."
echo " "

# Loop through patterns and run ag
for pattern in "${!patterns[@]}"; do
  run_ag "$pattern"
done

# Check if any patterns were found
if [ "$patterns_found" = "false" ]; then
  echo ""  
  echo "No vulnerabilities found."
else
  echo ""  
  echo "Potential vulnerabilities detected. Detailed results saved to $temp_output_file"
fi

# Appends the scan result to the log file
echo "scan completed on $(date)" >> "$log_file"
cat "$temp_output_file" >> "$log_file"
echo "" >> "$log_file"

# Notifies the user about the log file
echo "Scan completed. Logs are saved in $log_file."
